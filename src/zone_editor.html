<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hakoniwa Env Zone Editor — ROS JSON Export (TO-consistent)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-columns: 400px 1fr; height: 100%; }
    #sidebar {
      padding: 12px; border-right: 1px solid #ddd; overflow:auto; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    #map { width: 100%; height: 100%; }
    h1 { font-size: 16px; margin: 0 0 8px 0; }
    fieldset { margin-bottom: 10px; }
    label { display:block; font-size: 12px; margin: 6px 0 2px; }
    input[type="text"], input[type="number"] { width: 100%; padding: 6px; box-sizing: border-box; }
    .row { display:flex; gap:8px; }
    .row > div { flex:1; }
    button { padding: 8px 10px; margin-right: 6px; }
    .badge { display:inline-block; padding:2px 6px; background:#eee; border-radius: 6px; margin-right: 4px; }
    .hint { color:#666; font-size:12px; }
    textarea { width:100%; height:160px; }
    .zone-list { font-size: 12px; }
    .compass-wrap { display:flex; align-items:center; gap:12px; }
    .compass {
      width: 120px; height: 120px;
      border-radius: 50%; position: relative; user-select: none;
      border: 1px solid #bbb; background: radial-gradient(#fff, #f5f5f5);
      box-shadow: inset 0 0 8px rgba(0,0,0,0.08);
      touch-action: none;
    }
    .compass .label { position:absolute; font-size:10px; color:#666; }
    .compass .N { top:2px; left:50%; transform:translateX(-50%); }
    .compass .S { bottom:2px; left:50%; transform:translateX(-50%); }
    .compass .E { right:2px; top:50%; transform:translateY(-50%); }
    .compass .W { left:2px; top:50%; transform:translateY(-50%); }
    .needle {
      position:absolute; left:50%; top:50%;
      width: 2px; height: 42%;
      background:#d35400; transform-origin: center calc(100%);
      transform: translate(-50%, -100%) rotate(0deg);
      border-radius: 2px;
      box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }
    .center-dot {
      position:absolute; left:50%; top:50%;
      width:8px; height:8px; background:#d35400; border-radius:50%;
      transform: translate(-50%,-50%);
      box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }
    .compass-info { font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .toolbar { display:flex; align-items:center; gap:8px; font-size:12px; flex-wrap: wrap; }
    .toolbar label { display:inline; margin:0; }
    .sep { flex: 1 0 100%; height: 0; }
  </style>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <h1>Hakoniwa Env Zone Editor</h1>
    <div class="hint">UIは気象方位（FROM）。描画はTO方向（ENU）。JSONはROS座標・TOベクトルで出力。</div>

    <fieldset>
      <legend>原点（起動点）</legend>
      <label>Origin Lat</label>
      <input id="origin-lat" type="number" step="0.000001" value="35.666862">
      <label>Origin Lon</label>
      <input id="origin-lon" type="number" step="0.000001" value="139.692616">
      <div class="row">
        <div>
          <label>初期ズーム</label>
          <input id="init-zoom" type="number" min="1" max="20" value="15">
        </div>
        <div>
          <label>メートル表示補助</label>
          <span class="hint">右下のスケール参照</span>
        </div>
      </div>
      <button id="btn-center">原点へ移動</button>
    </fieldset>

    <fieldset>
      <legend>ゾーン設定（選択でロード・編集可）</legend>
      <div class="toolbar">
        <input type="checkbox" id="auto-apply" checked>
        <label for="auto-apply">入力変更を自動で適用</label>
      </div>
      <label>名前</label>
      <input id="zone-name" type="text" placeholder="block1">

      <div class="row">
        <div>
          <label>優先度 priority</label>
          <input id="zone-priority" type="number" value="1">
        </div>
        <div>
          <label>GPS 強度 (0..1)</label>
          <input id="zone-gps" type="number" step="0.05" min="0" max="1" value="0.8">
        </div>
      </div>

      <div class="row">
        <div>
          <label>風速 (m/s)</label>
          <input id="zone-wind-speed" type="number" step="0.1" value="3.0">
        </div>
        <div>
          <label>風向 (気象方位, °)</label>
          <input id="zone-wind-dir" class="mono" type="number" step="1" value="225">
        </div>
      </div>

      <div class="compass-wrap">
        <div id="compass" class="compass" title="クリック/ドラッグで風向(気象方位:どこから吹く)を設定">
          <div class="label N">N</div>
          <div class="label E">E</div>
          <div class="label S">S</div>
          <div class="label W">W</div>
          <div class="needle" id="needle"></div>
          <div class="center-dot"></div>
        </div>
        <div class="compass-info">
          <div>気象方位（FROM）: <span id="dir-deg" class="mono">225</span>°</div>
          <div>ENUベクトル (TO): <span id="vec-preview" class="mono">[?, ?, 0]</span></div>
          <div class="hint">※北=0°, 東=90°。FROM→TOへ自動変換</div>
          <div style="margin-top:6px;">
            <button id="btn-snap-45">45°刻みにスナップ</button>
          </div>
        </div>
      </div>

      <div style="margin-top:6px;">
        <button id="btn-apply">選択図形に適用</button>
        <button id="btn-delete">選択図形を削除</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>エクスポート</legend>
      <button id="btn-export">JSONを生成（ROS座標）</button>
      <button id="btn-download">ダウンロード</button>
      <div class="hint">rect/circle も ROS へ座標変換して出力します（meta.axis="ROS"）。</div>
      <textarea id="output" placeholder="ここにROS座標のJSONが出ます"></textarea>
    </fieldset>

    <fieldset>
      <legend>現在のゾーン</legend>
      <div id="zone-list" class="zone-list"></div>
    </fieldset>
  </div>
  <div id="map"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

<script>
function deg2rad(d){return d*Math.PI/180;}
function rad2deg(r){return r*180/Math.PI;}
function metersPerDegLat(){ return 111320.0; }
function metersPerDegLon(lat){ return 111320.0 * Math.cos(deg2rad(lat)); }
function latlonToENU(originLat, originLon, lat, lon){
  const dLat = lat - originLat;
  const dLon = lon - originLon;
  const mx = dLon * metersPerDegLon(originLat);
  const my = dLat * metersPerDegLat();
  return [mx, my];
}
function ENUToLatLon(originLat, originLon, x, y){
  const dLat = y / metersPerDegLat();
  const dLon = x / metersPerDegLon(originLat);
  return [originLat + dLat, originLon + dLon];
}
function enuToRos3(enu_x, enu_y, enu_z) {
  return [enu_y, -enu_x, enu_z]; // ENU -> ROS
}
function enuToRos2(enu_x, enu_y) {
  return [ enu_y, -enu_x ];
}
function windFromDirectionToENU(speed, metDirDeg){
  // FROM(deg) -> TO(deg) then ENU vector
  const flowTo = (metDirDeg + 180.0) % 360.0;
  const r = deg2rad(flowTo);
  const vx = Math.sin(r) * speed; // +E
  const vy = Math.cos(r) * speed; // +N
  return [vx, vy, 0.0];
}

const map = L.map('map', { preferCanvas: true });
const originLatInput = document.getElementById('origin-lat');
const originLonInput = document.getElementById('origin-lon');
const initZoomInput  = document.getElementById('init-zoom');
function centerMap(){
  const lat = parseFloat(originLatInput.value);
  const lon = parseFloat(originLonInput.value);
  const zoom = parseInt(initZoomInput.value || "15", 10);
  map.setView([lat, lon], zoom);
}
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);
L.control.scale().addTo(map);
centerMap();
document.getElementById('btn-center').onclick = centerMap;

const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

const drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems, edit: true, remove: true },
  draw: {
    polygon: false,
    polyline: false,
    marker: false,
    circlemarker: false,
    rectangle: { shapeOptions: { color: '#e67e22', weight: 2 } },
    circle:    { shapeOptions: { color: '#27ae60', weight: 2 } }
  }
});
map.addControl(drawControl);

let selectedLayer = null;
const arrowLayerGroup = L.layerGroup().addTo(map);

map.on(L.Draw.Event.CREATED, function (e) {
  const layer = e.layer;
  drawnItems.addLayer(layer);
  selectLayer(layer);
  refreshZoneList();
  renderArrows();
});
map.on('draw:edited', function(e){
  refreshZoneList();
  renderArrows();
});
map.on('draw:deleted', function(e){
  refreshZoneList();
  renderArrows();
});
map.on('click', function(e){
  let found = null;
  drawnItems.eachLayer(function(layer){
    if (layer.getBounds && layer.getBounds().contains(e.latlng)) {
      found = layer;
    }
  });
  if (found) selectLayer(found); else clearSelection();
});

function selectLayer(layer){
  clearSelection();
  selectedLayer = layer;
  if (selectedLayer.setStyle) selectedLayer.setStyle({ weight: 4 });
  const m = selectedLayer._hakoniwa || {};
  document.getElementById('zone-name').value     = m.name     ?? '';
  document.getElementById('zone-priority').value = m.priority ?? 1;
  document.getElementById('zone-gps').value      = m.gpsAbs   ?? 0.8;
  document.getElementById('zone-wind-speed').value  = m.windSpd  ?? 3.0;
  setDirectionDeg( Number.isFinite(m.windDir) ? m.windDir : 225 );
  refreshZoneList();
  renderArrows();
}
function clearSelection(){
  if (selectedLayer && selectedLayer.setStyle) selectedLayer.setStyle({ weight: 2 });
  selectedLayer = null;
}

const zoneName     = document.getElementById('zone-name');
const zonePriority = document.getElementById('zone-priority');
const zoneGPS      = document.getElementById('zone-gps');
const zoneWindSpd  = document.getElementById('zone-wind-speed');
const zoneWindDir  = document.getElementById('zone-wind-dir');
const autoApply    = document.getElementById('auto-apply');

const needle = document.getElementById('needle');
const dirDegEl = document.getElementById('dir-deg');
const vecPreviewEl = document.getElementById('vec-preview');
const compassEl = document.getElementById('compass');
const btnSnap45 = document.getElementById('btn-snap-45');

function updateCompassVisual(deg){
  needle.style.transform = `translate(-50%, -100%) rotate(${deg}deg)`;
  dirDegEl.textContent = Math.round(deg);
  const v = windFromDirectionToENU(parseFloat(zoneWindSpd.value||"0"), deg);
  vecPreviewEl.textContent = `[${v[0].toFixed(2)}, ${v[1].toFixed(2)}, 0]`;
}
function setDirectionDeg(deg){
  deg = (deg%360+360)%360;
  zoneWindDir.value = deg.toFixed(0);
  updateCompassVisual(deg);
  if (autoApply.checked) applyToSelected();
}
function getCenter(el){
  const r = el.getBoundingClientRect();
  return { cx: r.left + r.width/2, cy: r.top + r.height/2 };
}
function handlePointer(e){
  const { cx, cy } = getCenter(compassEl);
  const x = ('clientX' in e) ? e.clientX : (e.touches?.[0]?.clientX||0);
  const y = ('clientY' in e) ? e.clientY : (e.touches?.[0]?.clientY||0);
  const ang = Math.atan2(x - cx, cy - y); // 0 at North, CW positive
  const deg = (rad2deg(ang)+360)%360;
  setDirectionDeg(deg);
}
let dragging = false;
compassEl.addEventListener('pointerdown', e=>{ dragging=true; compassEl.setPointerCapture(e.pointerId); handlePointer(e); });
compassEl.addEventListener('pointermove', e=>{ if(dragging) handlePointer(e); });
compassEl.addEventListener('pointerup',   e=>{ dragging=false; try{compassEl.releasePointerCapture(e.pointerId);}catch{} });
compassEl.addEventListener('pointerleave',e=>{ dragging=false; });
zoneWindDir.addEventListener('input', e=>{ setDirectionDeg(parseFloat(e.target.value||"0")); });
zoneWindSpd.addEventListener('input', e=>{ updateCompassVisual(parseFloat(zoneWindDir.value||"0")); if (autoApply.checked) applyToSelected(); });
zoneName.addEventListener('input', ()=>{ if (autoApply.checked) applyToSelected(); });
zonePriority.addEventListener('input', ()=>{ if (autoApply.checked) applyToSelected(); });
zoneGPS.addEventListener('input', ()=>{ if (autoApply.checked) applyToSelected(); });
btnSnap45.addEventListener('click', ()=>{
  const v = parseFloat(zoneWindDir.value||"0");
  const snapped = Math.round(v/45)*45;
  setDirectionDeg(snapped);
});

setDirectionDeg(parseFloat(zoneWindDir.value||"225"));

document.getElementById('btn-apply').onclick = function(){ applyToSelected(true); };
document.getElementById('btn-delete').onclick = function(){
  if (!selectedLayer){ alert('図形を選択してください'); return; }
  drawnItems.removeLayer(selectedLayer);
  selectedLayer = null;
  refreshZoneList();
  renderArrows();
};

function applyToSelected(force=false){
  if (!selectedLayer) return;
  selectedLayer._hakoniwa = {
    name: zoneName.value || 'zone',
    priority: parseInt(zonePriority.value || "1", 10),
    gpsAbs: parseFloat(zoneGPS.value || "0.8"),
    windDir: parseFloat(zoneWindDir.value || "225"),
    windSpd: parseFloat(zoneWindSpd.value || "3.0")
  };
  refreshZoneList();
  renderArrows();
}

function layerCenterLatLng(layer){
  if (layer instanceof L.Rectangle){
    return layer.getBounds().getCenter();
  } else if (layer instanceof L.Circle){
    return layer.getLatLng();
  } else {
    return null;
  }
}

function layerToZoneJSON(layer){
  const originLat = parseFloat(originLatInput.value);
  const originLon = parseFloat(originLonInput.value);
  const meta = layer._hakoniwa || {};
  const base = {
    name: meta.name || 'zone',
    priority: (meta.priority != null ? meta.priority : 1),
    effect: { mode: "absolute", gps_abs: (meta.gpsAbs != null ? meta.gpsAbs : 0.8) }
  };

  // wind: ENU (TO) -> ROS
  const v = windFromDirectionToENU((meta.windSpd||3.0), (meta.windDir||225));
  const ros_v = enuToRos3(v[0], v[1], v[2]);
  base.effect.wind_ms = [ Number(ros_v[0].toFixed(3)), Number(ros_v[1].toFixed(3)), Number(ros_v[2].toFixed(3)) ];

  if (layer instanceof L.Rectangle){
    const b = layer.getBounds();
    const sw = b.getSouthWest(), ne = b.getNorthEast();
    const enuSW = latlonToENU(originLat, originLon, sw.lat, sw.lng);
    const enuNE = latlonToENU(originLat, originLon, ne.lat, ne.lng);
    // ENU → ROS
    const [rosSWx, rosSWy] = enuToRos2(enuSW[0], enuSW[1]);
    const [rosNEx, rosNEy] = enuToRos2(enuNE[0], enuNE[1]);
    const minx = Math.min(rosSWx, rosNEx), maxx = Math.max(rosSWx, rosNEx);
    const miny = Math.min(rosSWy, rosNEy), maxy = Math.max(rosSWy, rosNEy);
    base.shape = { rect: { min_m: [round(minx), round(miny)], max_m: [round(maxx), round(maxy)] } };
  } else if (layer instanceof L.Circle){
    const c = layer.getLatLng();
    const r = layer.getRadius();
    const enuC = latlonToENU(originLat, originLon, c.lat, c.lng);
    const [rosCx, rosCy] = enuToRos2(enuC[0], enuC[1]);
    base.shape = { circle: { center_m: [round(rosCx), round(rosCy)], radius_m: round(r) } };
  } else { return null; }
  return base;
}

function round(v){ return Math.round(v*10)/10; }

function exportJSON(){
  const zones = [];
  drawnItems.eachLayer(function(layer){
    const z = layerToZoneJSON(layer);
    if (z) zones.push(z);
  });
  const out = {
    version: "0.1",
    meta: {
      crs: "local-ros",
      origin_latlon: [
        parseFloat(originLatInput.value),
        parseFloat(originLonInput.value)
      ],
      axis: "ROS",
      units: { length: "m", speed: "m/s", temp: "C" }
    },
    zones: zones
  };
  return JSON.stringify(out, null, 2);
}

document.getElementById('btn-export').onclick = function(){
  document.getElementById('output').value = exportJSON();
};
document.getElementById('btn-download').onclick = function(){
  const blob = new Blob([exportJSON()], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = "env_zones_ros.json";
  a.click();
  URL.revokeObjectURL(url);
};

function refreshZoneList(){
  const list = document.getElementById('zone-list');
  let html = "";
  let idx = 1;
  drawnItems.eachLayer(function(layer){
    const meta = layer._hakoniwa || {};
    let label = meta.name || ('zone'+idx);
    const type = (layer instanceof L.Rectangle) ? 'rect' :
                 (layer instanceof L.Circle) ? 'circle' : 'shape';
    html += `<div><span class="badge">${type}</span>${label}`;
    if (meta.windSpd != null) html += ` <span class="badge">wind ${meta.windSpd} m/s @${meta.windDir}°</span>`;
    if (meta.gpsAbs != null) html += ` <span class="badge">gps ${meta.gpsAbs}</span>`;
    if (meta.priority != null) html += ` <span class="badge">prio ${meta.priority}</span>`;
    html += `</div>`;
    idx++;
  });
  list.innerHTML = html || "<i>なし</i>";
}

function renderArrows(){
  // Always draw TO direction in ENU
  arrowLayerGroup.clearLayers();
  const originLat = parseFloat(originLatInput.value);
  const originLon = parseFloat(originLonInput.value);

  drawnItems.eachLayer(function(layer){
    if (!layer._hakoniwa) return;
    const m = layer._hakoniwa;
    const v_to = windFromDirectionToENU((m.windSpd||0), (m.windDir||0)); // ENU (TO)
    const scale = 50;
    const center = layerCenterLatLng(layer);
    if (!center) return;

    const enuStart = latlonToENU(originLat, originLon, center.lat, center.lng);
    const enuEnd = [ enuStart[0] + v_to[0]*scale, enuStart[1] + v_to[1]*scale ];
    const [endLat, endLon] = ENUToLatLon(originLat, originLon, enuEnd[0], enuEnd[1]);

    L.polyline([[center.lat, center.lng], [endLat, endLon]], { color:'#d35400', weight:3 }).addTo(arrowLayerGroup);

    const angle = Math.atan2(endLon - center.lng, endLat - center.lat);
    const headLen = 0.0001;
    const left = [ endLat - headLen*Math.cos(angle - Math.PI/6), endLon - headLen*Math.sin(angle - Math.PI/6) ];
    const right= [ endLat - headLen*Math.cos(angle + Math.PI/6), endLon - headLen*Math.sin(angle + Math.PI/6) ];
    L.polyline([[endLat, endLon], left], { color:'#d35400', weight:3 }).addTo(arrowLayerGroup);
    L.polyline([[endLat, endLon], right], { color:'#d35400', weight:3 }).addTo(arrowLayerGroup);
  });
}
</script>
</body>
</html>
